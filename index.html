<!DOCTYPE html>
<html lang="en">
  <head>
    <title>three.js - pointerlock controls</title>
    <meta charset="utf-8" />
    <meta
      name="viewport"
      content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0"
    />
    <link type="text/css" rel="stylesheet" href="./main.css" />
    <style>
      #blocker {
        position: absolute;
        width: 100%;
        height: 100%;
        /* background-color: rgba(0, 0, 0, 0.5); */
      }

      #instructions {
        width: 100%;
        height: 100%;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;

        text-align: center;
        font-size: 14px;
        cursor: pointer;
      }
      /* #instructions {
				width: 100%;
				height: 100%;
				
				user-select: none;
				text-shadow: 1px 1px 1px #9E9E9E;
				
				position: absolute;
				width: 100%;
				height: 100%;
				background-color: rgba(0,0,0,0.5);

				display: -webkit-box;
				display: -moz-box;
				display: box;

				-webkit-box-orient: horizontal;
				-moz-box-orient: horizontal;
				box-orient: horizontal;

				-webkit-box-pack: center;
				-moz-box-pack: center;
				box-pack: center;

				-webkit-box-align: center;
				-moz-box-align: center;
				box-align: center;

				color: #ffffff;
				text-align: center;
				font-family: Arial;
				font-size: 14px;
				line-height: 24px;

				cursor: pointer;
} */
    </style>
  </head>
  <body>
    <div id="blocker">
      <div id="instructions">
        <!-- <p style="font-size: 36px">Click to Explore the Museum</p>
        <p>
          Move: WASD<br />
          Jump: SPACE<br />
          Look: MOUSE
        </p> -->
        <audio id="au" loop>
          <source src="./audio.mpeg"  type="audio/mpeg" >
      </audio>
      </div>
    </div>
    <script type="module">
      import * as THREE from "./three.module.js";

      import { PointerLockControls } from "./PointerLockControls.js";

      import { GLTFLoader } from "./GLTFLoader.js";
      import { RGBELoader } from "./RGBELoader.js";
      import { CanvasUI } from './CanvasUI.js';
      //   import { DRACOLoader } from "./DRACOLoader.js";

      let camera, scene, renderer, controls;

      const objects = [];

      let raycaster,raycaster1,raycaster2,raycaster3,raycaster4;

      let room1,room2,room3,room4,room5,room6,room7;
      const obj = [];
      let moveForward = false;
      let moveBackward = false;
      let moveLeft = false;
      let moveRight = false;
      let canJump = false;
      var arrow;

      let prevTime = performance.now();
      const velocity = new THREE.Vector3();
      const direction = new THREE.Vector3();
      const vertex = new THREE.Vector3();
      const color = new THREE.Color();
      var time = Date.now() * 0.0005;

      init();
      animate();
      

      function init() {
        camera = new THREE.PerspectiveCamera(
          75,
          window.innerWidth / window.innerHeight,
          1,
          1000
        );
         camera.position.x = 0;
         camera.position.y = 2;
        camera.position.z = -7;


        scene = new THREE.Scene();
        scene.background = new THREE.Color(0xffffff);
        scene.fog = new THREE.Fog(0xffffff, 0, 750);
        
        const light = new THREE.HemisphereLight(0xeeeeff, 0x777788, 0.75);
        light.position.set(0.5, 1, 0.75);
        scene.add(light);
        loadGLTF();

        
        controls = new PointerLockControls(camera, document.body);
        
        const blocker = document.getElementById("blocker");
        const instructions = document.getElementById("instructions");
        
        window.addEventListener( 'click', onClick, false );

        instructions.addEventListener("click", function () {
          controls.lock();
          document.getElementById("au").play();
        });

        controls.addEventListener("lock", function () {
          instructions.style.display = "none";
          blocker.style.display = "none";
        });

        controls.addEventListener("unlock", function () {
          blocker.style.display = "block";
          instructions.style.display = "";
        });

        scene.add(controls.getObject());

        const onKeyDown = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW":
              moveForward = true;
              break;

            case "ArrowLeft":
            case "KeyA":
              moveLeft = true;
              break;

            case "ArrowDown":
            case "KeyS":
              moveBackward = true;
              break;

            case "ArrowRight":
            case "KeyD":
              moveRight = true;
              break;

            case "Space":
              if (canJump === true) velocity.y += 350;
              canJump = false;
              break;
          }
        };

        const onKeyUp = function (event) {
          switch (event.code) {
            case "ArrowUp":
            case "KeyW":
              moveForward = false;
              break;

            case "ArrowLeft":
            case "KeyA":
              moveLeft = false;
              break;

            case "ArrowDown":
            case "KeyS":
              moveBackward = false;
              break;

            case "ArrowRight":
            case "KeyD":
              moveRight = false;
              break;
          }
        };

        document.addEventListener("keydown", onKeyDown);
        document.addEventListener("keyup", onKeyUp);

        // raycaster = new THREE.Raycaster(
        //   new THREE.Vector3(),
        //   new THREE.Vector3(0, -1, 0),
        //   0,
        //   10
        // );

        

        renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        document.body.appendChild(renderer.domElement);

        

        window.addEventListener("resize", onWindowResize);
      }

      function onClick() {
	event.preventDefault();
  const mouse = new THREE.Vector2()
  const raycaster1 = new THREE.Raycaster();
	mouse.x = ( event.clientX / window.innerWidth ) * 2 - 1;
	mouse.y = - ( event.clientY / window.innerHeight ) * 2 + 1;

	raycaster1.setFromCamera( mouse, camera );

	var intersects = raycaster1.intersectObjects( obj, true );

	if ( intersects.length > 0 ) {
	    console.log( 'Intersection:', intersects[ 0 ].object );
      // var object = intersects[0].object;

      // object.material.color.set( Math.random() * 0xffffff );
      createUI();
	}
}
function createUI() {
        const ui = new CanvasUI(  );
        ui.updateElement("body", "Hello World" );
        ui.update();
        ui.mesh.position.set( 5, 2.5, -11 );
        scene.add( ui.mesh );
    }

     
      function loadGLTF() {
        const loader = new GLTFLoader();

        // Load a glTF resource
        loader.load(
          // resource URL
          "../../assets/rooml.glb",
          // called when the resource is loaded
          function (gltf) {
            scene.add(gltf.scene);
            const room=gltf.scene.children[2];
            console.log(gltf.scene.children);
            room1=room.children[18];
            room2=room1.children;
            room3=room.children[16];
            room4=room.children[1];
            room5=room4.children;
            room6=room.children[19];
            room7=room6.children;
            objects.push(...room2);
            objects.push(room3);
            objects.push(...room5);
            obj.push(...room7);
            console.log(room7);
          },
          // called while loading is progressing
          function (xhr) {
            console.log((xhr.loaded / xhr.total) * 100 + "% loaded");
          },
          // called when loading has errors
          function (error) {
            console.log("An error happened");
          }
        );
      }

      function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();

        renderer.setSize(window.innerWidth, window.innerHeight);
      }

      function animate() {
        requestAnimationFrame(animate);

        const time = performance.now();

        if (controls.isLocked === true) {
            // raycaster.ray.origin.copy(controls.getObject().position);
            // console.log(controls.getObject().position);
          //   raycaster.ray.origin.y -= 10;
          // console.log(room1.children);
          // console.log(camera.projectionMatrix);

          const delta = (time - prevTime) / 1000;

velocity.x -= velocity.x * 10.0 * delta;
velocity.z -= velocity.z * 10.0 * delta;

velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

direction.z = Number(moveForward) - Number(moveBackward);
direction.x = Number(moveRight) - Number(moveLeft);
direction.normalize(); 



        const wall=2;
        let pos=controls.getObject().position;
        raycaster = new THREE.Raycaster();
        let dir = new THREE.Vector3();
        camera.getWorldDirection(dir);
        raycaster.set(pos,dir);
        let blocked=false;
        let intersect =raycaster.intersectObjects(objects);
        if(intersect.length>0){
          if(intersect[0].distance<wall) blocked=true;
        }
        if(blocked){
          if (moveForward)
            velocity.z -= direction.z * 0 * delta; 
            if (moveBackward)
            velocity.z -= direction.z * 100.0 * delta;
        //  if (moveLeft || moveRight) velocity.x -= direction.x * 150.0 * delta;

        }
        else{
          if (moveForward || moveBackward)
            velocity.z -= direction.z * 100.0 * delta;
          // if (moveLeft || moveRight) velocity.x -= direction.x * 150.0 * delta;
        
        }


        // raycaster1 = new THREE.Raycaster();
        // let dir1 = new THREE.Vector3();
        // dir1.set(-1,0,0)
        // raycaster1.set(pos,dir1);
        // let blocked1=false;
        // let intersect1 =raycaster1.intersectObjects(objects);
        // console.log(intersect1[0].distance);
        // if(intersect1.length>0){
        //   if(intersect1[0].distance<wall) blocked1=true;
        // }
        // console.log(blocked1);
        // if(blocked1){
        //   if (moveForward || moveBackward)
        //     velocity.z -= direction.z * 0 * delta;
        //   if (moveLeft) velocity.x -= direction.x * 0 * delta;
        //   if (moveRight) velocity.x -= direction.x * 0 * delta;

        // }
        // else{
        //   if (moveForward || moveBackward)
        //     velocity.z -= direction.z * 100.0 * delta;
        //   if (moveLeft || moveRight) velocity.x -= direction.x * 150.0 * delta;
        
        // }


        //left
        // dir.set(-1,0,0);
        // dir.applyMatrix4(camera.ProjectionMatrix);
        // dir.normalize();
        // raycaster.set(pos,dir);

        // intersect = raycaster.intersectObjects(objects);
        // if(intersect.length>0){
        //   if(intersect[0].distance<wall){
        //   if (moveForward || moveBackward)
        //      velocity.z -= direction.z * 100.0 * delta;
        //   if (moveLeft) velocity.x -= direction.x * 150.0 * delta;
        //   if (moveRight) velocity.x -= direction.x * 150.0 * delta;
        //   }
          
        // }




				// const pointer = new THREE.Vector2();
        // pointer.x = (0.5) * 2 - 1;
				// pointer.y = -1 * (0.5) * 2 + 1;
				// raycaster.setFromCamera(pointer, camera);
        // const intersections = raycaster.intersectObjects(objects);
         
        //   const onObject = intersections[0].distance < 2;
         //console.log(intersections[0].distance);
         //console.log(onObject);

        // const dir= new THREE.Vector3();
        // camera.getWorldDirection(dir);

        // console.log(dir);


        







          // const delta = (time - prevTime) / 1000;

          // velocity.x -= velocity.x * 10.0 * delta;
          // velocity.z -= velocity.z * 10.0 * delta;

          // velocity.y -= 9.8 * 100.0 * delta; // 100.0 = mass

          // direction.z = Number(moveForward) - Number(moveBackward);
          // direction.x = Number(moveRight) - Number(moveLeft);
          // direction.normalize(); // this ensures consistent movements in all directions

          // if (moveForward || moveBackward)
          //   velocity.z -= direction.z * 100.0 * delta;
          // if (moveLeft || moveRight) velocity.x -= direction.x * 150.0 * delta;
          

          //straight
         




          controls.moveRight(-velocity.x * delta);
          controls.moveForward(-velocity.z * delta);

          controls.getObject().position.y += velocity.y * delta; // new behavior

          if (controls.getObject().position.y < 10) {
            velocity.y = 0;
            controls.getObject().position.y = 2;

            canJump = true;
          }
        }

        prevTime = time;

        renderer.render(scene, camera);
      }
    </script>
  </body>
</html>